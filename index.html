<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Magic Puzzle </title>

  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    *,*::before,*::after{box-sizing:border-box}
    body,html{
      margin:0;padding:0;width:100%;height:100%;overflow:hidden;
      background:transparent !important;
      font-family:'Arial Rounded MT Bold', 'Arial', 'Helvetica Neue', sans-serif;
      touch-action:none;-webkit-tap-highlight-color:transparent;
    }
    a-scene{
      position:fixed;inset:0;background:transparent !important;
      pointer-events: none;
    }
    #puzzleCanvas{
      position:fixed;inset:0;z-index:100;background:transparent;display:none;
      pointer-events: auto;
    }
    #closeBtn{
      position:fixed;top:max(15px,env(safe-area-inset-top,15px));right:15px;
      width:60px;height:60px;background:#99ccff;color:white;border:none;
      border-radius:50%;font-size:32px;z-index:1002;box-shadow:0 0 30px #99ccff;
      cursor:pointer;display:none;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
    }
    .screen{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      flex-direction:column;color:white;z-index:1001;text-align:center;
      background:rgba(0,0,0,0.85);
      padding:20px;
    }
    #startScreen{
      background:radial-gradient(circle at center,rgba(153,204,255,0.7),transparent);
    }
    #winScreen h1{animation:pulse 1.5s infinite}
    @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.15)}}
    button{
      background:#99ccff;color:white;border:none;padding:18px 45px;
      border-radius:50px;font-size:30px;cursor:pointer;
      box-shadow:0 0 50px #99ccff;margin:15px;transition:.3s;
      min-height: 60px;
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      font-weight: bold;
      letter-spacing: 0.5px;
    }
    button:active{transform:scale(0.95)}

    #hintTextOnPuzzle{
      position:fixed;top:10px;left:10px;right:10px;color:white;font-weight:bold;
      text-align:center;z-index:1002;font-size:clamp(16px,4vw,24px);
      text-shadow:2px 2px 8px rgba(0,0,0,0.8);pointer-events:none;display:none;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 10px;
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      font-weight: bold;
    }

    /* –ö–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è –º–æ–≤–∏ */
    #langBtn{
      position:fixed;top:max(15px,env(safe-area-inset-top,15px));left:15px;
      background:#99ccff;color:white;border:none;padding:12px 18px;
      border-radius:30px;font-size:18px;font-weight:bold;z-index:1002;
      box-shadow:0 0 20px #99ccff;cursor:pointer;min-height: 44px;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
    }

    /* –ö–Ω–æ–ø–∫–∞ –∑–≤—É–∫—É */
    #soundBtn{
      position:fixed;bottom:max(20px,env(safe-area-inset-bottom,20px));right:20px;
      background:rgba(153,204,255,0.7);color:white;border:none;padding:15px;
      border-radius:50%;font-size:28px;z-index:1002;cursor:pointer;
      box-shadow:0 0 20px #99ccff;min-width: 50px; min-height: 50px;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
    }

    /* –ö–Ω–æ–ø–∫–∞ –∞–≤—Ç–æ—Ä–∞ AR */
    #authorBtn{
      position:fixed;bottom:max(20px,env(safe-area-inset-bottom,20px));left:20px;
      background:#4a90e2;color:white;border:none;padding:10px 16px;
      border-radius:25px;font-size:14px;font-weight:bold;z-index:1002;
      box-shadow:0 0 15px #4a90e2;cursor:pointer;min-height: 40px;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
      opacity: 0.9;
      transition: opacity 0.3s;
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      font-weight: bold;
    }

    #authorBtn:hover{
      opacity: 1;
    }

    /* –Ü–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è */
    #loadingIndicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 1003;
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 15px;
      display: none;
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      font-weight: bold;
    }

    /* –ó–∞–≥–æ–ª–æ–≤–∫–∏ */
    h1, h2 {
      font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    h1 {
      font-size: clamp(28px, 8vw, 48px);
    }

    h2 {
      font-size: clamp(22px, 6vw, 36px);
    }

    p {
      font-family: 'Arial', sans-serif;
      font-size: clamp(16px, 4vw, 20px);
      margin: 8px 0;
      line-height: 1.4;
      max-width: 90%;
    }
  </style>
</head>
<body>

  <canvas id="puzzleCanvas"></canvas>
  <button id="closeBtn">X</button>
  <div id="hintTextOnPuzzle"></div>
  <div id="loadingIndicator">Loading...</div>

  <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª—ñ–Ω–Ω—è -->
  <button id="langBtn">UA</button>
  <button id="soundBtn">On</button>
  <a href="https://smartlessa.etsy.com" target="_blank" id="authorBtn" 
     data-en="üë®‚Äçüíª Author AR" data-ua="üë®‚Äçüíª –ê–≤—Ç–æ—Ä AR">
    üë®‚Äçüíª Author AR
  </a>

  <!-- –ï–∫—Ä–∞–Ω–∏ -->
  <div id="startScreen" class="screen">
    <h1 data-en="Magic Puzzle" data-ua="–ú–∞–≥—ñ—á–Ω–∏–π –ø–∞–∑–ª">Magic Puzzle</h1>
    <p data-en="12 magical pictures for you" data-ua="12 —á–∞—Ä—ñ–≤–Ω–∏—Ö –∫–∞—Ä—Ç–∏–Ω–æ–∫ –¥–ª—è —Ç–µ–±–µ">12 magical pictures for you</p>
    <button id="startBtn" data-en="START THE MAGIC!" data-ua="–ü–û–ß–ê–¢–ò –ú–ê–ì–Ü–Æ!">START THE MAGIC!</button>
  </div>

  <div id="hintScreen" class="screen" style="display:none">
    <h2 data-en="Find any picture from the calendar!" data-ua="–ó–Ω–∞–π–¥–∏ –±—É–¥—å-—è–∫—É –∫–∞—Ä—Ç–∏–Ω–∫—É –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä—ñ!">
      Find any picture from the calendar!
    </h2>
    <p data-en="Show it to the camera" data-ua="–ü–æ–∫–∞–∂–∏ —ó—ó –∫–∞–º–µ—Ä—ñ">
      Show it to the camera
    </p>
  </div>

  <div id="winScreen" class="screen" style="display:none">
    <h1 data-en="HURRAY!" data-ua="–¢–∞–∫!">HURRAY!</h1>
   <p data-en="Puzzle completed! Well done!" data-ua="–ü–∞–∑–ª –∑—ñ–±—Ä–∞–Ω–æ! –ú–æ–ª–æ–¥–µ—Ü—å!">Puzzle completed! Well done!</p>
  </div>

  <!-- –§–æ–Ω–æ–≤–∞ –º—É–∑–∏–∫–∞ -->
  <audio id="bgMusic" loop preload="auto">
    <source src="fon23.mp3" type="audio/mp3">
  </audio>

  <a-scene embedded
    mindar-image="imageTargetSrc: ./calendar.mind; filterMinCF:0.001; filterBeta:0.01; warmupTolerance:5; autoStart:false; maxTrack: 2; missTolerance: 0;"
    renderer="colorManagement:true; physicallyCorrectLights:true; antialias:true; alpha:true"
    vr-mode-ui="enabled:false"
    device-orientation-permission-ui="enabled:false"
    loading-screen="enabled:false"
    style="position:fixed;inset:0;background:transparent !important;">
    <a-camera active="false" mindar-image-target></a-camera>
  </a-scene>

  <script>
    console.log('üöÄ –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–æ–¥–∞—Ç–∫—É...');
    
    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏
    const MAX_IMAGE_SIZE = 1200;
    const CONFETTI_COUNT = 60;
    const RESIZE_DELAY = 150;
    
    const PUZZLES = Array.from({length:12},(_,i)=>({
      id: i,
      image: `images/${String(i+1).padStart(2,'0')}.jpg`
    }));
    
    // –ì–ª–æ–±–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ
    let currentPuzzle = null;
    let started = false;
    let isUA = false;
    let isPuzzleActive = false;
    let resizeTimeout = null;
    let arSystem = null;

    let completed = new Set();
    try {
      const saved = localStorage.getItem('magicPuzzleProgress');
      if (saved) {
        const completedArray = JSON.parse(saved);
        if (Array.isArray(completedArray)) {
          completed = new Set(completedArray);
          console.log('üìä –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ –ø—Ä–æ–≥—Ä–µ—Å:', completed.size + '/12');
        }
      }
    } catch (e) {
      console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ø—Ä–æ–≥—Ä–µ—Å—É:', e);
    }

    function saveProgress() {
      try {
        localStorage.setItem('magicPuzzleProgress', JSON.stringify([...completed]));
      } catch (e) {
        console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ø—Ä–æ–≥—Ä–µ—Å—É:', e);
      }
    }

    // === –ú–ê–ì–Ü–ß–ù–ê –§–£–ù–ö–¶–Ü–Ø –î–õ–Ø –ü–ï–†–ï–ó–ê–ü–£–°–ö–£ AR ===
    function forceRestartMindAR() {
      if (!arSystem) {
        console.warn('‚ö†Ô∏è AR —Å–∏—Å—Ç–µ–º–∞ –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∞');
        return;
      }

      console.log('üîÑ Force restart MindAR...');

      // 1. –ü–æ–≤–Ω—ñ—Å—Ç—é –≤–±–∏–≤–∞—î–º–æ –≤—Å–µ, —â–æ –º–æ–∂–µ –±—É—Ç–∏
      try { 
        arSystem.stop(); 
        console.log('‚úÖ AR —Å–∏—Å—Ç–µ–º–∞ –∑—É–ø–∏–Ω–µ–Ω–∞');
      } catch(e) {
        console.warn('‚ö†Ô∏è –ù–µ –≤–¥–∞–ª–æ—Å—è –∑—É–ø–∏–Ω–∏—Ç–∏ AR:', e);
      }

      // 2. –ó—É–ø–∏–Ω—è—î–º–æ –≤—Å—ñ –≤—ñ–¥–µ–æ—Ç—Ä–µ–∫–∏
      if (arSystem.video && arSystem.video.srcObject) {
        const tracks = arSystem.video.srcObject.getTracks();
        tracks.forEach(track => {
          console.log('‚èπÔ∏è –ó—É–ø–∏–Ω—è—î–º–æ —Ç—Ä–µ–∫:', track.kind);
          track.stop();
        });
        arSystem.video.srcObject = null;
        console.log('‚úÖ –í—ñ–¥–µ–æ–ø–æ—Ç—ñ–∫ –æ—á–∏—â–µ–Ω–æ');
      }

      // 3. –û—á–∏—â–∞—î–º–æ –≤–Ω—É—Ç—Ä—ñ—à–Ω—ñ–π —Å—Ç–∞–Ω MindAR
      if (arSystem.controller) {
        arSystem.controller.stopProcessVideo = true;
        arSystem.controller.processVideo = null;
        console.log('‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª–µ—Ä –æ—á–∏—â–µ–Ω–æ');
      }

      // 4. –ü—Ä–∏–º—É—Å–æ–≤–æ —Å–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä—Ü—ñ
      arSystem.started = false;
      arSystem.paused = false;

      // 5. –ú–∞–ª–µ–Ω—å–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ + –Ω–æ–≤–∏–π —Å—Ç–∞—Ä—Ç
      setTimeout(() => {
        try {
          console.log('üé¨ –ó–∞–ø—É—Å–∫–∞—î–º–æ AR —Å–∏—Å—Ç–µ–º—É...');
          arSystem.start();
          console.log('‚úÖ MindAR —É—Å–ø—ñ—à–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω–æ –∑–∞–Ω–æ–≤–æ');
        } catch (err) {
          console.error('‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–ø—É—Å—Ç–∏—Ç–∏ MindAR –Ω–∞–≤—ñ—Ç—å –ø—Ä–∏–º—É—Å–æ–≤–æ', err);
          // –Ø–∫—â–æ –π —Ü–µ –Ω–µ –¥–æ–ø–æ–º–æ–≥–ª–æ ‚Äî –æ—Å—Ç–∞–Ω–Ω—ñ–π –∫–æ–∑–∏—Ä:
          setTimeout(() => {
            console.log('üîÑ –°–ø—Ä–æ–±—É—î–º–æ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É...');
            // location.reload();
          }, 1000);
        }
      }, 300);
    }

    const music = document.getElementById('bgMusic');
    music.volume = 0.3;
    let soundOn = false;

    function playMusic() {
      if (soundOn && music.paused) {
        music.play().catch(e => {
          console.log('üîá –ê–≤—Ç–æ–ø–ª–µ–π –º—É–∑–∏–∫–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ');
        });
      }
    }

    function setLanguage(ua) {
      isUA = ua;
      document.querySelectorAll('[data-ua]').forEach(el => {
        if (el.dataset.ua && el.dataset.en) {
          el.textContent = ua ? el.dataset.ua : el.dataset.en;
        }
      });
      document.getElementById('langBtn').textContent = ua ? 'EN' : 'UA';
      document.getElementById('hintTextOnPuzzle').textContent = ua ?
        '–ü–µ—Ä–µ—Ç—è–≥—É–π —à–º–∞—Ç–æ—á–∫–∏ –ø–∞–ª—å—á–∏–∫–æ–º!' : 'Drag the pieces with your finger!';
      document.getElementById('loadingIndicator').textContent = ua ? '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...' : 'Loading...';
      document.getElementById('authorBtn').textContent = ua ? 'üë®‚Äçüíª –ê–≤—Ç–æ—Ä AR' : 'üë®‚Äçüíª Author AR';
    }

    document.getElementById('langBtn').onclick = () => {
      console.log('üåê –ü–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è –º–æ–≤–∏:', !isUA ? 'UA' : 'EN');
      setLanguage(!isUA);
    };

    document.getElementById('soundBtn').onclick = () => {
      soundOn = !soundOn;
      if (soundOn) {
        music.play().then(() => {
          console.log('üîä –ú—É–∑–∏–∫–∞ —É–≤—ñ–º–∫–Ω–µ–Ω–∞');
        }).catch(e => {
          console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è –º—É–∑–∏–∫–∏:', e);
          soundOn = false;
        });
      } else {
        music.pause();
        console.log('üîá –ú—É–∑–∏–∫–∞ –≤–∏–º–∫–Ω–µ–Ω–∞');
      }
      document.getElementById('soundBtn').textContent = soundOn ? 'On' : 'Off';
    };

    const screens = {
      show(name) {
        console.log('üñ•Ô∏è –ü–µ—Ä–µ—Ö—ñ–¥ –Ω–∞ –µ–∫—Ä–∞–Ω:', name);
        
        ['start','hint','win'].forEach(s => {
          const element = document.getElementById(s + 'Screen');
          if (element) element.style.display = 'none';
        });
        
        document.getElementById('puzzleCanvas').style.display = 'none';
        document.getElementById('closeBtn').style.display = 'none';
        document.getElementById('hintTextOnPuzzle').style.display = 'none';
        document.getElementById('loadingIndicator').style.display = 'none';
        
        if (name === 'puzzle') {
          document.getElementById('puzzleCanvas').style.display = 'block';
          document.getElementById('closeBtn').style.display = 'block';
          document.getElementById('hintTextOnPuzzle').style.display = 'block';
          document.getElementById('authorBtn').style.display = 'none';
          isPuzzleActive = true;
          
          // –ó—É–ø–∏–Ω—è—î–º–æ AR
          if (arSystem && arSystem.started) {
            arSystem.stop();
            console.log('‚è∏Ô∏è AR —Å–∏—Å—Ç–µ–º–∞ –∑—É–ø–∏–Ω–µ–Ω–∞ (–ø–∞–∑–ª –∞–∫—Ç–∏–≤–Ω–∏–π)');
          }
          
        } else if (name === 'loading') {
          document.getElementById('loadingIndicator').style.display = 'block';
          document.getElementById('authorBtn').style.display = 'none';
        } else {
          const screenElement = document.getElementById(name + 'Screen');
          if (screenElement) {
            screenElement.style.display = 'flex';
          }
          document.getElementById('authorBtn').style.display = 'flex';
          isPuzzleActive = false;
          
          // –ó–∞–ø—É—Å–∫–∞—î–º–æ AR –Ω–∞ –µ–∫—Ä–∞–Ω—ñ –ø—ñ–¥–∫–∞–∑–∫–∏ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é forceRestart
          if (name === 'hint') {
            setTimeout(() => {
              forceRestartMindAR();
            }, 600);
          }
        }
      }
    };

    class PuzzleRenderer {
      constructor(c) {
        this.c = c;
        this.ctx = c.getContext('2d', { alpha: true });
        this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
        this.resize();
        
        // –î–µ–±–∞—É–Ω—Å resize
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => this.resize(), RESIZE_DELAY);
        });
      }
      
      resize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        this.c.width = width * this.pixelRatio;
        this.c.height = height * this.pixelRatio;
        this.c.style.width = width + 'px';
        this.c.style.height = height + 'px';
        
        this.ctx.scale(this.pixelRatio, this.pixelRatio);
        
        if (currentPuzzle) {
          currentPuzzle.render();
        }
      }
      
      render(pieces, dragged) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        this.ctx.clearRect(0, 0, width, height);
        if (!pieces || !pieces.length) return;
        
        const maxSize = Math.min(width * 0.85, height * 0.65);
        const cell = Math.max(maxSize / 3, 80);
        const w = cell;
        const h = cell * (pieces[0].aspectRatio || 1);
        const totalW = w * 3;
        const totalH = h * 3;
        const cx = (width - totalW) / 2;
        const cy = (height - totalH) / 2;
        
        this.ctx.strokeStyle = '#99ccff';
        this.ctx.lineWidth = 6;
        this.ctx.strokeRect(cx - 10, cy - 10, totalW + 20, totalH + 20);
        
        pieces.forEach(piece => {
          try {
            this.ctx.drawImage(
              piece.sourceImage,
              piece.sx, piece.sy, piece.sw, piece.sh,
              piece.x, piece.y, piece.width, piece.height
            );
            
            if (piece === dragged) {
              this.ctx.strokeStyle = '#99ccff';
              this.ctx.lineWidth = 4;
              this.ctx.strokeRect(piece.x, piece.y, w, h);
            }
          } catch (e) {
            console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —à–º–∞—Ç–æ—á–∫–∞:', e);
          }
        });
      }
    }

    class PuzzleEngine {
      constructor(cfg, rend) {
        this.cfg = cfg;
        this.rend = rend;
        this.pieces = [];
        this.drag = null;
        this.off = { x: 0, y: 0 };
        this.init();
      }
      
      async init() {
        console.log('üß© –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–∞–∑–ª–∞:', this.cfg.id);
        try {
          const img = await this.loadImage(this.cfg.image);
          await this.createPieces(img);
          this.setupEvents();
          this.rend.render(this.pieces);
        } catch (error) {
          console.error('‚ùå –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó –ø–∞–∑–ª–∞:', error);
          await this.fallback();
        }
      }
      
      async loadImage(src) {
        return new Promise((resolve, reject) => {
          const image = new Image();
          image.crossOrigin = "anonymous";
          
          image.onload = () => {
            console.log('‚úÖ –ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ:', src, `(${image.width}x${image.height})`);
            
            // –ú–∞—Å—à—Ç–∞–±—É—î–º–æ –≤–µ–ª–∏–∫—ñ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
            if (image.width > MAX_IMAGE_SIZE || image.height > MAX_IMAGE_SIZE) {
              const scale = MAX_IMAGE_SIZE / Math.max(image.width, image.height);
              const canvas = document.createElement('canvas');
              canvas.width = image.width * scale;
              canvas.height = image.height * scale;
              const ctx = canvas.getContext('2d');
              
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
              
              const optimizedImage = new Image();
              optimizedImage.crossOrigin = "anonymous";
              optimizedImage.onload = () => {
                console.log('üìê –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–æ –¥–æ:', canvas.width + 'x' + canvas.height);
                resolve(optimizedImage);
              };
              optimizedImage.onerror = reject;
              optimizedImage.src = canvas.toDataURL('image/jpeg', 0.9);
            } else {
              resolve(image);
            }
          };
          
          image.onerror = reject;
          image.src = src + '?t=' + Date.now();
        });
      }
      
      async createPieces(img) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        const maxSize = Math.min(width * 0.85, height * 0.65);
        const cell = Math.max(maxSize / 3, 80);
        const pieceWidth = cell;
        const pieceHeight = cell * (img.height / img.width);
        const totalW = pieceWidth * 3;
        const totalH = pieceHeight * 3;
        const ox = (width - totalW) / 2;
        const oy = (height - totalH) / 2;
        const sw = img.width / 3;
        const sh = img.height / 3;
        
        const safeAreaPadding = 20;
        const minX = safeAreaPadding;
        const maxX = width - pieceWidth - safeAreaPadding;
        const minY = safeAreaPadding;
        const maxY = height - pieceHeight - safeAreaPadding;
        
        for (let r = 0; r < 3; r++) {
          for (let c = 0; c < 3; c++) {
            let x, y;
            let attempts = 0;
            const maxAttempts = 20;
            
            do {
              x = minX + Math.random() * (maxX - minX);
              y = minY + Math.random() * (maxY - minY);
              attempts++;
              
              let hasOverlap = false;
              for (const existingPiece of this.pieces) {
                const dx = Math.abs(x - existingPiece.x);
                const dy = Math.abs(y - existingPiece.y);
                if (dx < pieceWidth * 1.2 && dy < pieceHeight * 1.2) {
                  hasOverlap = true;
                  break;
                }
              }
              
              if (!hasOverlap || attempts >= maxAttempts) break;
            } while (attempts < maxAttempts);
            
            if (attempts >= maxAttempts) {
              const gridCol = c;
              const gridRow = r;
              x = ox + (gridCol - 1) * pieceWidth * 1.5;
              y = oy + (gridRow - 1) * pieceHeight * 1.5;
              
              x = Math.max(minX, Math.min(maxX, x));
              y = Math.max(minY, Math.min(maxY, y));
            }

            this.pieces.push({
              sourceImage: img,
              sx: c * sw,
              sy: r * sh,
              sw: sw,
              sh: sh,
              width: pieceWidth,
              height: pieceHeight,
              x: x,
              y: y,
              tx: ox + c * pieceWidth,
              ty: oy + r * pieceHeight,
              ok: false,
              aspectRatio: img.height / img.width
            });
          }
        }
        
        // –ü–µ—Ä–µ–º—ñ—à—É—î–º–æ
        for (let i = this.pieces.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [this.pieces[i], this.pieces[j]] = [this.pieces[j], this.pieces[i]];
        }
      }
      
      setupEvents() {
        const c = this.rend.c;
        
        const start = (e) => {
          e.preventDefault();
          const rect = c.getBoundingClientRect();
          const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
          const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
          
          for (let i = this.pieces.length - 1; i >= 0; i--) {
            const piece = this.pieces[i];
            if (x >= piece.x && x <= piece.x + piece.width && 
                y >= piece.y && y <= piece.y + piece.height) {
              this.drag = piece;
              this.off = { x: x - piece.x, y: y - piece.y };
              this.pieces.splice(i, 1);
              this.pieces.push(piece);
              break;
            }
          }
        };
        
        const move = (e) => {
          if (!this.drag) return;
          e.preventDefault();
          const rect = c.getBoundingClientRect();
          const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
          const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
          
          this.drag.x = x - this.off.x;
          this.drag.y = y - this.off.y;
          this.rend.render(this.pieces, this.drag);
        };
        
        const end = () => {
          if (!this.drag) return;
          
          const dx = this.drag.x + this.drag.width/2 - (this.drag.tx + this.drag.width/2);
          const dy = this.drag.y + this.drag.height/2 - (this.drag.ty + this.drag.height/2);
          const distance = Math.sqrt(dx*dx + dy*dy);
          
          if (distance < 40) {
            this.drag.x = this.drag.tx;
            this.drag.y = this.drag.ty;
            this.drag.ok = true;
            this.checkCompletion();
          }
          
          this.drag = null;
          this.rend.render(this.pieces);
        };
        
        c.addEventListener('mousedown', start);
        c.addEventListener('touchstart', start, { passive: false });
        c.addEventListener('mousemove', move);
        c.addEventListener('touchmove', move, { passive: false });
        c.addEventListener('mouseup', end);
        c.addEventListener('touchend', end);
        c.addEventListener('touchcancel', end);
      }
      
      checkCompletion() {
        if (this.pieces.every(p => p.ok)) {
          console.log('üéâ –ü–∞–∑–ª –∑–∞–≤–µ—Ä—à–µ–Ω–æ:', this.cfg.id);
          completed.add(this.cfg.id);
          saveProgress();
          
          confetti({ 
            particleCount: CONFETTI_COUNT, 
            spread: 60, 
            origin: { y: 0.6 },
            ticks: 80 
          });
          
          setTimeout(() => {
            screens.show('win');
            setTimeout(() => {
              this.cleanup();
              currentPuzzle = null;
              isPuzzleActive = false;
              nextPuzzle();
            }, 3000);
          }, 1000);
        }
      }
      
      cleanup() {
        const c = this.rend.c;
        c.replaceWith(c.cloneNode(true));
        this.pieces.forEach(p => {
          p.sourceImage = null;
        });
        this.pieces = [];
      }
      
      render() {
        this.rend.render(this.pieces, this.drag);
      }
      
      async fallback() {
        console.log('üîÑ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –ø–∞–∑–ª–∞');
        const colors = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FFEAA7','#DDA0DD','#98D8C8','#F7DC6F','#BB8FCE'];
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.18;
        
        const safeAreaPadding = 20;
        const minX = safeAreaPadding;
        const maxX = window.innerWidth - size - safeAreaPadding;
        const minY = safeAreaPadding;
        const maxY = window.innerHeight - size - safeAreaPadding;
        
        const total = size * 3;
        const ox = (window.innerWidth - total) / 2;
        const oy = (window.innerHeight - total) / 2;
        
        for (let i = 0; i < 9; i++) {
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = colors[i];
          ctx.fillRect(0, 0, size, size);
          ctx.fillStyle = 'white';
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(i + 1, size / 2, size / 2);
          
          const img = new Image();
          await new Promise(resolve => {
            img.onload = resolve;
            img.src = canvas.toDataURL();
          });
          
          const row = Math.floor(i / 3);
          const col = i % 3;
          
          const x = Math.max(minX, Math.min(maxX, 
            ox + Math.random() * (window.innerWidth - size * 2)));
          const y = Math.max(minY, Math.min(maxY, 
            oy + Math.random() * (window.innerHeight - size * 2)));
          
          this.pieces.push({
            sourceImage: img,
            sx: 0, sy: 0, sw: size, sh: size,
            width: size,
            height: size,
            x: x,
            y: y,
            tx: ox + col * size,
            ty: oy + row * size,
            ok: false,
            aspectRatio: 1
          });
        }
        this.setupEvents();
        this.rend.render(this.pieces);
      }
    }

    function nextPuzzle() {
      const remaining = PUZZLES.filter(p => !completed.has(p.id));
      
      if (remaining.length === 0) {
        console.log('üèÜ –í—Å—ñ –ø–∞–∑–ª–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!');
        screens.show('start');
        started = false;
        return;
      }
      
      screens.show('hint');
      
      // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ forceRestart –∑–∞–º—ñ—Å—Ç—å –ø—Ä–æ—Å—Ç–æ–≥–æ start
      setTimeout(() => {
        forceRestartMindAR();
      }, 500);
    }

    document.getElementById('startBtn').onclick = async () => {
      if (started) return;
      started = true;
      console.log('üé¨ –ó–∞–ø—É—Å–∫ –¥–æ–¥–∞—Ç–∫—É...');
      
      try {
        screens.show('loading');
        
        await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        console.log('üìπ –ö–∞–º–µ—Ä–∞ —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞');
        
        screens.show('hint');
        playMusic();
        
        // –ó–∞–ø—É—Å–∫–∞—î–º–æ AR —á–µ—Ä–µ–∑ forceRestart –¥–ª—è –Ω–∞–¥—ñ–π–Ω–æ—Å—Ç—ñ
        setTimeout(() => {
          forceRestartMindAR();
        }, 300);
        
      } catch (error) {
        console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏:', error);
        alert(isUA ? "–î–æ–∑–≤–æ–ª—å –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏!" : "Allow camera access!");
        started = false;
        screens.show('start');
      }
    };

    document.getElementById('closeBtn').onclick = () => {
      console.log('üîô –ó–∞–∫—Ä–∏—Ç—Ç—è –ø–∞–∑–ª–∞');
      if (currentPuzzle) {
        currentPuzzle.cleanup();
        currentPuzzle = null;
      }
      isPuzzleActive = false;
      
      setTimeout(() => {
        nextPuzzle();
      }, 300);
    };

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è AR
    const scene = document.querySelector('a-scene');
    
    scene.addEventListener('renderstart', () => {
      console.log('üéÆ A-Frame —Å—Ü–µ–Ω–∞ –≥–æ—Ç–æ–≤–∞');
      
      // –û—Ç—Ä–∏–º—É—î–º–æ AR —Å–∏—Å—Ç–µ–º—É
      arSystem = scene.systems['mindar-image-system'];
      
      // –°—Ç–≤–æ—Ä—é—î–º–æ AR entity
      PUZZLES.forEach(cfg => {
        const entity = document.createElement('a-entity');
        entity.setAttribute('mindar-image-target', `targetIndex: ${cfg.id}`);
        
        entity.addEventListener('targetFound', () => {
          console.log('üéØ –ó–Ω–∞–π–¥–µ–Ω–æ –º–∞—Ä–∫–µ—Ä:', cfg.id);
          
          if (isPuzzleActive) {
            console.log('‚õî –Ü–≥–Ω–æ—Ä—É—î–º–æ –º–∞—Ä–∫–µ—Ä: –ø–∞–∑–ª –≤–∂–µ –∞–∫—Ç–∏–≤–Ω–∏–π');
            return;
          }
          
          if (completed.has(cfg.id)) {
            console.log('‚úÖ –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –≤–∂–µ –∑—ñ–±—Ä–∞–Ω–∏–π –ø–∞–∑–ª:', cfg.id);
            return;
          }
          
          console.log('üéÆ –ó–∞–ø—É—Å–∫–∞—î–º–æ –Ω–æ–≤–∏–π –ø–∞–∑–ª:', cfg.id);
          currentPuzzle = new PuzzleEngine(cfg, new PuzzleRenderer(document.getElementById('puzzleCanvas')));
          screens.show('puzzle');
        });
        
        entity.addEventListener('targetLost', () => {
          console.log('üëª –í—Ç—Ä–∞—á–µ–Ω–æ –º–∞—Ä–∫–µ—Ä:', cfg.id);
        });
        
        scene.appendChild(entity);
      });
      
      setLanguage(false);
      console.log('‚úÖ –î–æ–¥–∞—Ç–æ–∫ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ');
    });

    // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫ –ø–æ–º–∏–ª–æ–∫
    window.addEventListener('error', (e) => {
      console.error('üí• –ì–ª–æ–±–∞–ª—å–Ω–∞ –ø–æ–º–∏–ª–∫–∞:', e.error);
    });

    window.addEventListener('unhandledrejection', (e) => {
      console.error('üí• –ù–µ–æ–±—Ä–æ–±–ª–µ–Ω–∞ –ø—Ä–æ–º—ñ—Å-–ø–æ–º–∏–ª–∫–∞:', e.reason);
    });

    // –û—á–∏—â–µ–Ω–Ω—è –ø—Ä–∏ –∑–∞–∫—Ä–∏—Ç—Ç—ñ
    window.addEventListener('beforeunload', () => {
      if (currentPuzzle) {
        currentPuzzle.cleanup();
        currentPuzzle = null;
      }
      isPuzzleActive = false;
      clearTimeout(resizeTimeout);
    });

    screens.show('start');
  </script>
</body>
</html>
